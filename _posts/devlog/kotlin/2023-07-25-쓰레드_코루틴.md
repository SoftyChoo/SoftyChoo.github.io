---
layout: post
title: kotlin
image: /assets/img/kotlin_img/kotlin.png
accent_image: 
  background: url('/assets/img/change_img/book.jpg') center/cover
  overlay: false
accent_color: '#fff'
theme_color: '#fff'
description: >
  kotlin
invert_sidebar: true
categories :
 - devlog	
 - kotlin








---

# [Android/Kotlin] [TIL] 쓰레드(Tread)와 코루틴(Coroutine)의 차이

쓰레드와 코루틴의 차이에 대해 알아보자

* toc
{:toc}


💡 **동시성 프로그래밍을 다시 정리해보자**

- 설명
  - 쓰레드와 코루틴은 둘 다 동시성 프로그래밍을 위한 기술이다.
  - 동시성 프로그래밍 기술은 **[컨텍스트 스위칭](https://ko.wikipedia.org/wiki/문맥_교환)**이 중요한 개념이다.

💡 **쓰레드와 코루틴의 차이를 정리해보자**

- 쓰레드

  - 작업 하나하나의 단위 : Thread
    - 각 Thread 가 독립적인 **Stack 메모리 영역을 가진다.**
  - 동시성 보장 수단 : Context Switching
    - 운영체제 커널에 의한 **Context Switching** 을 통해 동시성을 보장한다.
    - 블로킹(Blocking)
      - Thread A가 Thread B 의 **결과를 기다리고 있다.**
    - 이 때, Thread A는 블로킹 상태라고 할 수 있다.
      - A는 Thread B 의 **결과가 나올 때 까지 해당 자원을 사용하지 못한다.**

  ### 예시

  [![img](https://camo.githubusercontent.com/006000867b092aee95e064eb2d9ba50d520d722964814abd6aa089db324340d5/68747470733a2f2f7465616d7370617274612e6e6f74696f6e2e736974652f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324634343334373966322d633037362d343661312d393633392d636534363735316164643562253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d35323436343762352d393166662d343962312d616332332d36373462386233313036313426737061636549643d38336337356133392d336162612d346261342d613739322d3761656665346230373839352677696474683d31343430267573657249643d2663616368653d7632)](https://camo.githubusercontent.com/006000867b092aee95e064eb2d9ba50d520d722964814abd6aa089db324340d5/68747470733a2f2f7465616d7370617274612e6e6f74696f6e2e736974652f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324634343334373966322d633037362d343661312d393633392d636534363735316164643562253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d35323436343762352d393166662d343962312d616332332d36373462386233313036313426737061636549643d38336337356133392d336162612d346261342d613739322d3761656665346230373839352677696474683d31343430267573657249643d2663616368653d7632)

- Thread A가 Task 1을 수행하는 동안 Task 2 의 결과가 필요하면 Thread B를 호출한다.

- 이때 Thread A는 블로킹 되고 Thread B로 프로세스간에 스위칭이 일어나 Task 2을 수행한다.

- Task 2가 완료되면 Thead A로 다시 스위칭해서 결과 값을 Task 1에게 반환한다.

- 이때 Task 3, Task 4는 A, B작업이 진행되는 도중에 멈추지 않고 각각 동시에 실행되게 된다.

- 이때 컴퓨터 운영체제 입장에서는 각 Task를 쪼개서 얼마나 수행할지가 중요한데

- 그래서 어떤 쓰레드를 먼저 실행해야할지 결정하는행위를 스케쥴링이라고 한다.

- 이러한 행위를 통해 동시성을 보장한다.

------

- 코루틴

- 작업 하나하나의 단위 : Coroutine Object
  - 여러 작업 각각에 Object 를 할당한다.
  - Coroutine Object 도 엄연한 객체이기 때문에 **JVM Heap 에 적재** 한다.(코틀린 기준)
- 동시성 보장 수단 : Programmer Switching (No-Context Switching)
  - 소스 코드를 통해 **Switching** 시점을 **마음대로** 정한다. (OS는 관여하지 않아요)
  - Suspend(Non-Blocking)
    - Object 1이 Object 2의 **결과를 기다릴 때** Object 1의 상태는 **Suspend로 바뀐다.**
    - 그래도 Object 1을 수행하던 ****Thread는 그대로 유효하다\****
    - 그래서 Object 2도 Object 1과 **동일한 Thread**에서 실행된다.

### 예시

[![img](https://camo.githubusercontent.com/b4827a1f1fe6c06fe161f86280405009d10f01008764a45737537fc664e3b761/68747470733a2f2f7465616d7370617274612e6e6f74696f6e2e736974652f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324665613234613662342d616633302d346338312d386536332d383238666536336638323635253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d37663637303261372d316664612d343062652d616464652d31376665653433636436353426737061636549643d38336337356133392d336162612d346261342d613739322d3761656665346230373839352677696474683d31383830267573657249643d2663616368653d7632)](https://camo.githubusercontent.com/b4827a1f1fe6c06fe161f86280405009d10f01008764a45737537fc664e3b761/68747470733a2f2f7465616d7370617274612e6e6f74696f6e2e736974652f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324665613234613662342d616633302d346338312d386536332d383238666536336638323635253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d37663637303261372d316664612d343062652d616464652d31376665653433636436353426737061636549643d38336337356133392d336162612d346261342d613739322d3761656665346230373839352677696474683d31383830267573657249643d2663616368653d7632)

- Coroutine은 작업 단위가 Object라고 했다.
- Task 1을 수행하다가 Task 2의 수행요청이 발생했다고 가정해보겠다.
- 신기하게도 컨텍스트 스위칭 없이 동일한 Thread A에서 수행할 수 있다.
- Thread C처럼 하나의 쓰레드에서 여러 Task Object들을 동시에 수행할 수 있다.
- 이러한 특징때문에 코루틴을 Light-Weight Thread라고 이야기한다.
  - 동시처리를 위해 스택영역을 별도로 할당하는 쓰레드처럼 동작하지 않는다.
  - 하지만 동시성을 보장할 수 있다.
  - 하나의 쓰레드에서 다수의 코루틴을 수행할 수 있다.
  - **커널의 스케쥴링을 따르는 컨텍스트 스위칭을 수행하지 않는다.**
- 요약
  - 쓰레드나 코루틴은 각자의 방법으로 동시성을 보장하는 기술이다.
  - 코루틴은 Thread를 대체하는 기술이 아니다.
  - 하나의 Thread를 더욱 잘개 쪼개서 사용하는 기술이다.
  - 코루틴은 쓰레드보다 CPU 자원을 절약하기 때문에 **Light-Weight Thread**라고 한다.
  - 구글에서는 코틀린의 코루틴 사용을 **적극 권장**하고 있다.